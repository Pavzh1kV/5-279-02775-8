/* ******************************************************************* */
/*   readme.txt - о программах к главе 4, каталог  GLAVA4              */
/* =================================================================== */
/*    Accerman.c и Acceraxo.cpp -  вычисление функции Аккермана.       */
/*	Демонстрируют использование рекурсивных функций и степень быстроты  */
/*	переполнения системного стека с последующим аварийным завершением   */
/*	программы. Имеются два неравнозначных определения функции Аккермана.*/
/*	В книге [26 - Трамбле, с.216] функция Аккермана определяется так:   */
/*				 | n+1,             если m=0;                              */
/*	А(m,n) =  | A(m-1,1),        если n=0;                              */
/*				 | A(m-1,A(m,n-1)), в остальных случаях.                   */
/*                                                                     */
/*	В книге [31 - Ахо, с.174] другое определение функции Аккермана:     */
/*				 | A(0,y)=1        для любого y>=0;                        */
/*	A(x,y) =  | A(1,0)=2;                                               */
/*				 | A(x,0)=x+2      для любого x>=2;                        */
/*				 | A(A(x-1,y),y-1) для всех x,y>=1.                        */
/*  Переполнение системного стека происходит гораздо быстрее при       */
/*  вычислении функции по второму определению.                         */
/* =================================================================== */
/*   codzam.c - задача о кодовом замке. Демонстрирует переборный       */
/*	алгоритм. Число вариантов равно числу сочетаний из n=9 по m=3:      */
/*	n!/(m!*(n-m)!)=84. Искомый ключ - любое трехзначное десятичное      */
/*	число. Учтено, что код можно набирать в любой перестановке:         */
/* 125, 215, 152 и т.д.																  */
/* =================================================================== */
/*   fact.c, fact1.c, fact2.c, factoria.c - разные варианты программ   */
/*	вычисления факториала. Имеется возможность проследить за резуль-    */
/*	татами по шагам выполнения рекурсивной функции, следить за адресами */
/*	локальных переменных, выделяемых в стеке. Получение результатов в   */
/*	виде целых чисел быстро приводит к переполнению числа, результаты   */
/*	становятся ошибочными.                                              */
/* =================================================================== */
/* Задача о расстановке 8 ферзей. Демонстрация задачи выбора,          */
/*	эвристический алгоритм (метод проб и ошибок)                        */
/*	  ferzi.c - нерекурсивный вариант, без функции, все 92 возможных    */
/*	решения.                                                            */
/*	  ferziR1.c - рекурсивный вариант, только одно решение.             */
/*	  ferzir2.c - рекурсивный вариант, любое число решений можно задать */
/*	при вызове функции.                                                 */
/* =================================================================== */
/*   hanoi.c - известная задача о ханойских башнях. Переборный алгоритм*/
/*	Можно следить за процессом переноса дисков по трем стержням (А,В,С).*/
/* =================================================================== */
/*   incl_hfm.cpp - таблица и функции для кодирования и декодирования  */
/* по	алгоритму Хаффмана. Работа не только с байтами и словами, но и их*/
/*	частями, т.е. битами.                                               */
/*	  huffman.cpp - программа, использующая эти средства.               */
/* =================================================================== */
/* Вычисление маршрута коня при обходе шахматной доски размером n*n.   */
/*	  koni.c - индивидульная задача обхода, обход начинается с верхнего */
/*	левого угла. Рекурсивная функция. Алгоритм с возвратом.             */
/*	  konigkn4.cpp - то же, но целенаправленный обход, за счет чего     */
/*	устраняются рекурсия и возвраты, сложность алгоритма O(n*n).        */
/*	  konigkn3.cpp - демонстрация того, что предыдущий алгоритм решает  */
/*	индивидуальную задачу. Замена массивов возможных перемещений        */
/*	приводит к ошибкам вычислений                                       */
/* =================================================================== */
/* Задача о рюкзаке. Имеется n предметов различных весов и ценности.   */
/*	Необходимо так отобрать вещи, чтобы их общий вес не превышал        */
/*	заданного значения, а ценность была максимальна. Это задача         */
/*	оптимального выбора.                                                */
/*	  rucz03.cpp - программа с рекурсивной функцией. Перебор уменьшается*/
/*	за счет упорядочения весов по возрастанию. Несколько вариантов      */
/*	задания предельного веса рюкзака.                                   */
/*	  rucztst.c - показ динамики отбора вещей.                          */
/* =================================================================== */
/* Вычисление чисел Фибоначчи:                                         */
/*						  fib.c - нерекурсивная функция;                     */
/*						  fibr.c - рекурсивная функция.                      */                             */
/* =================================================================== */
/* Подсчет числа счастливых билетов, переборная задача:                */
/*						happy6.c - билеты - шестизначные десятичные числа;   */
/*						happyk.c - k-значные десятичные числа.               */                  */
/* =================================================================== */
/* nod.cpp - нахождение наибольшего общего делителя двух целых чисел.  */
/* ******************************************************************* */
