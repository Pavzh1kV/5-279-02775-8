/* ******************************************************** */
/*   ПСЕВДОСОРТИРОВКА МАССИВА ПО СУММАМ СТРОК - МЕТОД ПУЗЫРЬКА
	  исходный массив остается на месте без перестановок,
	  создается массив индексов, который содержит индексы
	  строк якобы отсортированного массива. По этим ин-
	  дексам выбираются строки в порядке возрастания сумм
	  элементов  строк. Недостаток - не освобождается
	  динамическая память  */
/* \SortSum.cpp    */
#include <stdio.h>
#include <locale.h>
#include <stdlib.h>
//#include <conio.h>
//#include <alloc.h>
#include <stdlib.h>
#define n 8
#define m 5
float A[n][m];

/* ======================================================= */
main()
{
    setlocale(LC_ALL,"Russian");
    int *SortSum(float A[][m], int nn, int mm);
    int i, j, *Ind;
    float s;			/* Ind - указатель на массив индексов строк */
    printf
    ("\n Сортировка массива по суммам строк");

    /* Инициализация исходного массива случайными числами */
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            A[i][j] = rand() / 100;

    printf
    ("\n  Исходный массив  и суммы строк \n");
    for (i = 0; i < n; i++)
    {
        s = 0;
        for (j = 0; j < m; j++)
        {
            printf(" %8.1f", A[i][j]);
            s += A[i][j];
        }
        printf(" %8.1f \n", s);
    }

    /*  Вызов функции псевдосортировки */
    Ind = SortSum(A, n, m);

    printf
    ("\n Выборка элементов массива в порядке возрастания сумм");
    printf("\n  Отсортированный  массив \n");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < m; j++)
            printf(" %8.1f", A[Ind[i]][j]);
        printf("\n");
    }
    getchar();
    return 0;
}

/* ============================================================= */
/*   ФУНКЦИЯ СОРТИРОВКИ МЕТОДОМ ПУЗЫРЬКА  */
int *SortSum(float A[][m], int nn, int mm)
{
    int i, j, p;
    int *N, k;
    float *S, R;
    S = (float *) calloc(nn, sizeof(float));	/* массив сумм */
    N = (int *) calloc(nn, sizeof(int));	/* массив индексов */

    /* Инициализация массива индексов и массива сумм */
    for (i = 0; i < nn; i++)
    {
        N[i] = i;
        S[i] = A[i][0];
        for (j = 1; j < mm; j++)
            S[i] = S[i] + A[i][j];
    }

    /* Сортировка массива сумм и сохранение первоначальных индексов
       строк в массиве индексов */
    for (i = 0; i < nn - 1; i++)
    {
        p = 0;
        for (j = nn - 1; j > i; j--)
            if (S[j] < S[j - 1])
            {
                R = S[j];
                S[j] = S[j - 1];
                S[j - 1] = R;
                p = 1;
                k = N[j];
                N[j] = N[j - 1];
                N[j - 1] = k;
            }
        /* Если перестановок не было, то сортировка выполнена */
        if (p == 0)
            break;
    }

    /* Отладочная печать */
    printf
    ("\n  Массив индексов и отсортированный массив сумм");
    for (i = 0; i < nn; i++)
        printf("\n %d %8.1f", N[i], S[i]);
    getchar();
    free(S);
    /* Возврат указателя массива индексов */
    return N;
}

/* ************************************************************ */
