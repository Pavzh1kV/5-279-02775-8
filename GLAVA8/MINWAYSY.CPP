/* ******************************************************* */
/* ВЫЧИСЛЕНИЕ КРАТЧАЙШИХ ПУТЕЙ МЕЖДУ ЗАДАННОЙ И ОСТАЛЬНЫМИ */
/* ВЕРШИНАМИ ПО АЛГОРИТМУ ДЕЙКСТРЫ \minwaysy.cpp           */
#include <stdio.h>
#include <locale.h>
#include <stdlib.h>
//#include <conio.h>
#define t 9
#define n 50
void dijkstra(int A[n][n], int m, int v0, int FROM[n], int TO[n],
              int LENGTH[n]);
/* R - матрица смежности взвешенного неориентированного графа */
int R[t][t] = { 0, 7, 10, 0, 0, 0, 0, 0, 0,
                7, 0, 0, 9, 27, 0, 0, 0, 0,
                10, 0, 0, 8, 0, 0, 0, 0, 31,
                0, 9, 8, 0, 0, 11, 0, 0, 0,
                0, 27, 0, 0, 0, 0, 15, 0, 0,
                0, 0, 0, 11, 0, 0, 15, 17, 0,
                0, 0, 0, 0, 15, 15, 0, 21, 0,
                0, 0, 0, 0, 0, 17, 21, 0, 32,
                0, 0, 31, 0, 0, 0, 0, 32, 0
              };

/* B - матрица смежности взвешенного орграфа */
int B[t][t] = { 0, 7, 10, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 9, 27, 0, 0, 0, 0,
                0, 0, 0, 8, 0, 0, 0, 0, 31,
                0, 0, 0, 0, 0, 11, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 15, 0, 0,
                0, 0, 0, 0, 0, 0, 15, 17, 0,
                0, 0, 0, 0, 0, 0, 0, 21, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 32,
                0, 0, 0, 0, 0, 0, 0, 32, 0
              };

/* ==================================================== */
/*  ГЛАВНАЯ ФУНКЦИЯ */
int main()
{
    setlocale(LC_ALL,"Russian");
    int EDGES, i, j, V0, W;
    static int m;
    int A[n][n];
    int FROM[n];
    int TO[n];
    int LENGTH[n];
    printf
    ("\n\nВычисление кратчайшего пути между заданной и");
    printf
    ("\n остальными вершинами взвешенного графа \n");
    printf("\n  Введите число вершин графа=>");
    scanf("%d", &m);
    for (i = 1; i <= m; i++)
        for (j = 1; j <= m; j++)
            /* Не вводим расстояния, а используем готовый массив */
            /*   { printf(" Введите расстояние A[%d,%d]=>",i,j);
               scanf("%d",&A[i][j]);     */
        {
            A[i][j] = B[i - 1][j - 1];
            if (A[i][j] == 0)
                A[i][j] = 10000;	/* нет ребра */
        }

    while (1)  			/* Можно искать пути от различных начальных вершин */
    {
        while (2)
        {
            printf
            ("\nВведите начальную вершину или 0 для завершения =>");
            if (!scanf("%d", &V0))
            {
                printf("\n ОШИБКА!");
                continue;
            }
            if (V0 == 0)
                return 0;
            if (V0 < 1 || V0 > m)
            {
                printf("\n ОШИБКА !!!");
                continue;
            }
            break;
        }
        /* Вызов функции поиска кратчайшего пути */
        dijkstra(A, m, V0, FROM, TO, LENGTH);

        /* Печать расстояний на кратчайшем пути */
        printf("\nДуги и расстояния на кратчайшем пути,\
	начальная вершина %d:",
               V0);
        for (i = 1; i < m; i++)
            printf
            ("\n i= %d Начало=%d, Конец=%d, Расстояние=%d",
             i, FROM[i], TO[i], LENGTH[i]);
        getchar();
    }
    return 0;
}

/* ======================================================== */
/* ФУНКЦИЯ ВЫЧИСЛЕНИЯ КРАТЧАЙШИХ ПУТЕЙ ОТ ЗАДАННОЙ ВЕРШИНЫ
	ДО ВСЕХ ОСТАЛЬНЫХ ВЕРШИН */
void
dijkstra(int A[n][n], int m, int V0, int FROM[n], int TO[n], int LENGTH[n])
{
    int i, j, jk, k, L, edges, next, numun, p;
    int undet[n];
    int vertex[n];
    int dist[n];
    /* Инициализация переменных */
    edges = 0;			/* текущее число ребер в дереве кратчайших путей */
    next = m;			/* очередная вершина, присоединяемая к ДКП */
    numun = m - 1;		/* число неопеределенных вершин */
    for (i = 1; i <= m; i++)
    {
        undet[i] = i;		/* массив неопределенных вершин */
        dist[i] = A[V0][i];	/* кратчайшее расстояние от undet[i] до  */
        /* частичного дерева кратчайших путей */
        vertex[i] = V0;
    }
    undet[V0] = m;
    dist[V0] = dist[m];
    /* Основной цикл - обновление кратчайшего расстояния до всех
       неопределенных вершин */
    while (numun >= 1)  	/* Запоминание кратчайшего расстояния до неопределенной вершины */
    {
        k = 1;
        L = dist[1];
        for (i = 1; i <= numun; i++)
        {
            if (dist[i] >= L)
                continue;
            L = dist[i];
            k = i;
        }
        /*  Включение ребра в ДКП */
        edges = edges + 1;
        FROM[edges] = vertex[k];
        TO[edges] = undet[k];
        LENGTH[edges] = L;
        next = undet[k];
        /* Исключение вновь определенной вершины из списка неопределенных */
        dist[k] = dist[numun];;
        undet[k] = undet[numun];
        vertex[k] = vertex[numun];
        /* Число  неопределенных вершин */
        numun = numun - 1;
        for (i = 1; i <= numun; i++)
        {
            j = undet[i];
            jk = L + A[next][j];
            if (dist[i] <= jk)
                continue;
            vertex[i] = next;
            dist[i] = jk;
        }
    }
}

/* ****************************************************** */
