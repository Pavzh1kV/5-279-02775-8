/* ************************************************ */
/*   ВЫЧИСЛЕНИЕ КРАТЧАЙШИХ ПУТЕЙ И МАРШРУТОВ МЕЖДУ  */
/*   ВСЕМИ ВЕРШИНАМИ ВЗВЕШЕННОГО ГРАФА ПО АЛГОРИТМУ */
/*   ФЛОЙДА \floyd29.c  */
#include <stdio.h>
#include <locale.h>
#include <stdlib.h>
//#include <conio.h>
#define t 6			/* число вершин графа */
/* ================================================ */
/* ФУНКЦИЯ ВЫЧИСЛЕНИЯ КРАТЧАЙШИХ ПУТЕЙ И МАРШРУТОВ
	Алгоритм Флойда.
	S - исходная взвешенная матрица смежностей,
	А - вычисленная матрица кратчайших путей,
	M - матрица маршрутов,
	n - число вершин графа   */

void Floyd(int *A, int *S, int *M, int n)
{
    int i, j, k;
    /* Исходную взвешенную матрицу смежностей S не изменяем,
       копируем в вычисляемую матрицу кратчайших путей, при
       этом нулевые веса ребер заменяем на бесконечность - 1000,
       одновременно обнуляем матрицу маршрутов */
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
        {
            A[i * n + j] = (S[i * n + j] == 0) ? 1000 : S[i * n + j];
            M[i * n + j] = 0;
        }
    /* Обнуляем диагональные элементы матрицы А */
    for (i = 0; i < n; i++)
        A[i * n + i] = 0;
    /* Вычисляем эелементы матрицы кратчайших путей
       и матрицы маршрутов */
    for (k = 0; k < n; k++)
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                if (A[i * n + k] + A[k * n + j] < A[i * n + j])
                {
                    A[i * n + j] = A[i * n + k] + A[k * n + j];
                    M[i * n + j] = k + 1;
                }
}

/* ====================================================== */
/* РЕКУРСИВНАЯ ФУНКЦИЯ ПЕЧАТИ КРАТЧАЙШЕГО ПУТИ МЕЖДУ ДВУМЯ
	ВЕРШИНАМИ i и j */
int PrintPath(int *M, int n, int i, int j)
{
    int k;
    int static m = 0;
    static int s = 0;
    k = M[(i - 1) * n + j - 1];
    if (k == 0)
    {
        k = m;
        m = 0;
        return k;
    }
    PrintPath(M, n, i, k);
    {
        printf("%4d", k);
        m++;
    }
    PrintPath(M, n, k, j);
    s = 0;
}

/* ================================================== */
/* ВЫВОД СООБЩЕНИЯ О КРАТЧАЙШЕМ ПУТИ МЕЖДУ ВЕРШИНАМИ i и j*/
void MinPath(int *M, int *A, int n, int i, int j)
{
    int m;
    if (A[(i - 1) * n + j - 1] == 1000)
        printf("\n Между вершинами %d и %d нет пути",
               i, j);
    else
    {
        printf
        ("\n Кратчайший путь между вершинами %d и %d равен %d",
         i, j, A[(i - 1) * n + j - 1]);
        printf("\n и проходит через вершины:\n");
        m = PrintPath(M, n, i, j);
        if (m == 0)
            printf(" вершины смежны");
        getchar();
    }
}

/* ================================================ */
/* B - матрица смежности взвешенного неориентированного графа */
/* int B[t][t] =       {0,7,10,0,0,0,0,0,0,
							 7,0,0,9,27,0,0,0,0,
							 10,0,0,8,0,0,0,0,31,
							 0,9,8,0,0,11,0,0,0,
							 0,27,0,0,0,0,15,0,0,
							 0,0,0,11,0,0,15,17,0,
							 0,0,0,0,15,15,0,21,0,
							 0,0,0,0,0,17,21,0,32,
							 0,0,31,0,0,0,0,32,0};*/
/* D - матрица смежности взвешенного ориентированного графа */
/* int D[t][t] =       {0,7,10,0,0,0,0,0,0,
							 0,0,0,9,27,0,0,0,0,
							 0,0,0,8,0,0,0,0,31,
							 0,0,0,0,0,11,0,0,0,
							 0,0,0,0,0,0,15,0,0,
							 0,0,0,0,0,0,15,17,0,
							 0,0,0,0,0,0,0,21,0,
							 0,0,0,0,0,0,0,0,0,
							 0,0,0,0,0,0,0,32,0};*/
int C[6][6] = { 0, 8, 2, 4, 0, 0,
                0, 0, 0, 0, 7, 0,
                0, 0, 0, 6, 0, 14,
                0, 3, 0, 0, 15, 0,
                0, 0, 0, 0, 0, 1,
                0, 0, 0, 1, 0, 0
              };

/* ========================================================= */
/*  ГЛАВНАЯ ФУНКЦИЯ */
int main()
{
    setlocale(LC_ALL,"Russian");
    int A[t][t], P[t][t], i, j, p = 0;
    printf
    ("\n Вычисление кратчайшего пути между вершинами  \n");
    printf
    ("     в неориентированном взвешенном графе");
    Floyd(A, C, P, 6);
    printf("\n Матрица кратчайших путей:");
    for (i = 0; i < t; i++)
    {
        printf("\n");
        for (j = 0; j < t; j++)
            printf(" %4d", (A[i][j] == 1000) ? -1 : A[i][j]);
    }
    getchar();
    printf("\n Матрица маршрутов:");
    for (i = 0; i < t; i++)
    {
        printf("\n");
        for (j = 0; j < t; j++)
            printf(" %4d", P[i][j]);
    }
    getchar();
    while (1)
    {
        p = 0;
        printf
        ("\nВведите через пробел номера вершин,\
  между которыми определяется путь=>");
        while (1)
        {
            if (scanf("%d %d", &i, &j) != 2)
            {
                printf
                ("Ошибка: введите 2 номера через пробел=>");
                fflush(NULL);
                continue;
            }
            if (i == 0 && j == 0)
            {
                p = 1;
                break;
            }
            if (i < 1 || i > t || j < 1 || j > t)
            {
                printf
                ("Ошибка: вершины должны лежать в пределах от 1 до %d=>",
                 t);
                continue;
            }
            else
                break;
        }
        if (p)
            break;
        MinPath(P, A, t, i, j);
    }
    printf("\n Конец работы");
    getchar();
}

/* *********************************************************** */
