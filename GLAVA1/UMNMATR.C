/* ********************************************************* */
/* Умножение матриц С = А * B. Два варианта функций
   \umnmatr.c  */
/* Транслятор с Си позволяет  параметры-двухмерные_массивы
   задавать в различных формах: А, *А, &A (имеющих одно и то же
   значение), т.е. нет проверки соответствия типов формального
   параметра в прототипе и фактического параметра при вызове функции.
   Это возлагает особую ответственность на программиста за
   правильное использование параметра !!! */
/*    Так, в вызовах umn_mat1(A,B,&d,m,n,q) и umn_mat2(A,B,&d,m,n,q)
   третий параметр &d задан ошибочно, но транслятор принимает его как
   допустимый вариант, и, естественно, результат неверен!!! */
/* Транслятор с С++ выявляет все несоответствия типов формального и
   фактического параметров. Смотри программу umnmatr.cpp */
#include <stdio.h>
#include <locale.h>
#include <stdlib.h>
#include <stdlib.h>
#include <memory.h>
#define m 3
#define n 2
#define q 3
int A[m][n];
int B[n][q];
int C[m][q];
void umn_mat1(int *a, int *b, int *c, int mm, int nn, int qq);
void umn_mat2(int a[][n], int b[][q], int c[][q], int mm, int nn, int qq);
void pr_mas(int *ar, int mm, int nn);
/* ================================================================= */
/*  ГЛАВНАЯ ФУНКЦИЯ    */
main()
{
    setlocale(LC_ALL,"Russian");
    int i, j;
    int *d;
    system("clear");
    printf
    ("\n Умножение двух целочисленных матриц");
    printf
    ("\n Ввод элементов матрицы А - целые числа\n");
    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++)
        {
            printf(" Введите элемент A[%d][%d] =>", i, j);
            scanf("%d", &A[i][j]);
        }
    printf
    ("\n Ввод элементов матрицы В - целые числа\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < q; j++)
        {
            printf("\n Введите элемент B[%d][%d} =>", i, j);
            scanf("%d", &B[i][j]);
        }
    printf("\n Печать исходных матриц A и В:");
    pr_mas(*A, m, n);
    pr_mas(&B, n, q);
    /* Получим динамическую память  под массив и поместим
       туда результат умножения матриц А и В */
    d = (int *) malloc(sizeof(int) * m * n);
    umn_mat1(*A, *B, d, m, n, q);
    printf
    ("\n Вариант 1, результирующий массив:");
    pr_mas(d, m, q);
    /* Умножение матриц с вычислением индексов и печать */
    umn_mat1(&A, *B, C, m, n, q);
    printf
    ("\n Вариант 2, результирующий массив:");
    pr_mas(C, m, q);
    /* Умножение матриц с обычной индексацией и печать */
    umn_mat2(*A, &B, C, m, n, q);
    printf
    ("\n Вариант 3, результирующий массив:");
    pr_mas(C, m, q);
    printf(" A=%p *A=%p &A=%p", A, *A, &A);	/* одно и то же значение
						   для двухмерного массива, для одномерного массива d - нет!!! */
    printf
    ("\n Ошибочные варианты задания третьего параметра:");
    umn_mat1(A, B, &d, m, n, q);
    pr_mas(d, m, q);
    getchar();
    umn_mat2(A, B, &d, m, n, q);
    pr_mas(d, m, q);
    getchar();
    return 0;
}

/* =================================================================== */
/* УМНОЖЕНИЕ МАТРИЦ С ИСПОЛЬЗОВАНИЕМ УКАЗАТЕЛЕЙ И ВЫЧИСЛЕНИЕМ ИНДЕКСОВ */
void umn_mat1(int *a, int *b, int *c, int mm, int nn, int qq)
{
    int i, j, k;
    for (i = 0; i < mm; i++)
        for (j = 0; j < qq; j++)
        {
            c[i * qq + j] = 0;
            for (k = 0; k < nn; k++)
                c[i * qq + j] += (a[i * nn + k] * b[k * qq + j]);
        }
}

/* ============================================================== */
/* УМНОЖЕНИЕ МАТРИЦ С ОБЫЧНОЙ ИНДЕКСАЦИЕЙ ЭЛЕМЕНТОВ МАТРИЦ */
void umn_mat2(int a[][n], int b[][q], int c[][q], int mm, int nn, int qq)
{
    int i, j, k;
    for (i = 0; i < mm; i++)
        for (j = 0; j < qq; j++)
        {
            c[i][j] = 0;
            for (k = 0; k < nn; k++)
                c[i][j] += a[i][k] * b[k][j];
        }
}

/* ============================================================= */
/*  ПЕЧАТЬ ЭЛЕМЕНТОВ МАССИВА */
void pr_mas(int *ar, int mm, int nn)
{
    int i, j;
    printf("\n Элементы массива:");
    for (i = 0; i < mm; i++)
    {
        printf("\n");
        for (j = 0; j < nn; j++)
            printf(" %d", *(ar + i * nn + j));
    }
    getchar();
}

/* ************************************************************ */
