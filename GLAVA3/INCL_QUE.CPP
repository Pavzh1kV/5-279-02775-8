/* ***************************************************** */
/*  Файл включения с дескриптором очереди и функциями    */
/*	 для работы с очередью. Включается в головной файл    */
/*	 после определения структуры элемента очереди с       */
/*	 именем EL.     \incl_que.cpp                         */
#define  QUE struct ss
QUE				/* дескриптор очереди */
{
    EL *un;			/* указатель начала вектора */
    int uk;			/* указатель конца вектора */
    int ug;			/* указатель головы очереди */
    int ux;			/* указатель хвоста очереди */
    int m;			/* число элементов в векторе */
} q1;				/* q1 - переменная типа QUE */

EL e;
static EL nullel;
/* ======================================================== */
/*      ДОБАВЛЕНИЕ ЭЛЕМЕНТА В ОЧЕРЕДЬ   */
int Add_el(QUE * s, EL el)
{
    if (s->un == NULL)		/* Очередь не создана */
        return -2;
    /* Очередь полна, включение невозможно: */
    if ((s->ux + 1 == s->ug) || ((s->ux == s->uk) && (s->ug <= 0)))
        return -1;		/* очередь полна */
    /* Включение в пустую очередь: */
    if (s->ux == -1)
    {
        ++s->ux;
        *s->un = el;
        ++s->ug;
        return 0;
    }
    /* Включение элемента возможно: */
    if ((s->ux + 1 < s->ug) || ((s->ug <= s->ux) && (s->ux < s->uk)))
    {
        *(s->un + s->ux + 1) = el;
        ++s->ux;
        return 0;
    }
    if ((s->ux == s->uk) && (s->ug > 0))
    {
        *s->un = el;
        s->ux = 0;
        return 0;
    }
    return 0;
}

/* ========================================================= */
/*       ВЫБОРКА ЭЛЕМЕНТА ИЗ ОЧЕРЕДИ    */
int Extr_el(QUE * s, EL * el)
{
    int ret;
    if (s->un == NULL)
    {
        printf("\n Очередь не создана!");
        return -2;		/* очередь не создана */
    }
    if (s->ux < 0)
    {
        printf("\n Очередь пуста!");
        return -1;
    }
    if (s->ug == s->ux)
    {
        *el = *(s->un + s->ug);
        *(s->un + s->ug) = nullel;
        s->ux = -1;
        s->ug = -1;
    }
    else if (s->ug < s->ux)
    {
        *el = *(s->un + s->ug);
        *(s->un + s->ug) = nullel;
        ++s->ug;
    }
    else  			/* т.е. (s->ug > s->ux) */
    {

        *el = *(s->un + s->ug);
        *(s->un + s->ug) = nullel;
        if (s->ug == s->uk)
            s->ug = 0;
        else
            ++s->ug;
    }
    return 0;
}

/* ====================================================== */
/*       ОСВОБОЖДЕНИЕ ОЧЕРЕДИ       */
int Destroy_que(QUE * s)
{
    free(s->un);
    s->un = NULL;
    return 0;
}

/* ========================================================= */
/*      СОЗДАНИЕ ОЧЕРЕДИ           */
int Crt_que(QUE * s)
{
    int nn;			/* для ввода числа элементов */
    if (s->un != NULL)
    {
        printf
        ("\n Старую очередь уничтожить ? (y/n)");
        fflush(NULL);
        if (getchar() != 'y')
        {
            printf
            ("\n Работаем со старой очередью");
            return -2;
        }
        else
            free(s->un);
    }
    printf
    ("\n Введите число элементов очереди =>");
    scanf("%d", &nn);
    s->un = (EL *) calloc(nn, sizeof(EL));
    if (s->un == NULL)
        return -1;		/* память не выделена */
    else
    {
        s->ug = -1;
        s->ux = -1;
        s->uk = nn - 1;
        s->m = nn;
        return 0;
    }
}

/* ======================================================== */
/* ПРОВЕРКА ПУСТОТЫ ОЧЕРЕДИ  */
int Empty_que(QUE * s)
{
    if (s->un == NULL)
        return -1;
    if (s->ux == -1)		/* очередь пуста */
        return 0;
    else
        return 1;
}

/* ******************************************************* */
